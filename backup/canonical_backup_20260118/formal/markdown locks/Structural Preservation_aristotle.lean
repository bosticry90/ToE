/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 37847a54-4d32-45fe-a45d-dfb680e29991
-/

/-
This module formalizes the structural preservation of plane-wave dispersion in the 2D linear Schrödinger limit. It defines the field, plane-wave template, and dispersion relation. It establishes redundant algebraic equivalences and proves operator-level reduction results under explicitly stated axioms. Finally, it shows that admissible perturbations preserve the reduced dispersion form.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of a 2D field as a function from x, y, t (Reals) to Complex.
-/
abbrev Field2D : Type := ℝ → ℝ → ℝ → ℂ

/-
Definition of omega and its expansion theorem.
-/
def omega (kx ky : ℝ) : ℝ := (kx ^ 2 + ky ^ 2) / 2

theorem omega_expand (kx ky : ℝ) : omega kx ky = (kx ^ 2 + ky ^ 2) / 2 := rfl

/-
Definition of a plane wave.
-/
def planeWave (A : ℂ) (kx ky : ℝ) : Field2D :=
  fun x y t => A * Complex.exp (Complex.I * (kx * x + ky * y - omega kx ky * t))

/-
Redundant definitions and algebraic equivalences.
-/
def omegaF (kx ky : ℝ) : ℝ := omega kx ky
def lambdaO (kx ky : ℝ) : ℝ := (kx ^ 2 + ky ^ 2) / 2

theorem omegaF_eq_omega (kx ky : ℝ) : omegaF kx ky = omega kx ky := rfl
theorem lambdaO_eq_omega (kx ky : ℝ) : lambdaO kx ky = omega kx ky := rfl
theorem routeF_equals_routeO (kx ky : ℝ) : omegaF kx ky = lambdaO kx ky := rfl

/-
Structure defining the operators and their axioms, and the definition of L and EQ02Holds.
-/
structure SchrodingerOperators where
  Dt : Field2D → Field2D
  Dxx : Field2D → Field2D
  Dyy : Field2D → Field2D
  Delta : Field2D → Field2D
  Dt_planeWave : ∀ (A : ℂ) (kx ky : ℝ), Dt (planeWave A kx ky) = fun x y t => -Complex.I * omega kx ky * planeWave A kx ky x y t
  Delta_planeWave : ∀ (A : ℂ) (kx ky : ℝ), Delta (planeWave A kx ky) = fun x y t => -2 * omega kx ky * planeWave A kx ky x y t

def L (ops : SchrodingerOperators) (f : Field2D) : Field2D :=
  fun x y t => Complex.I * ops.Dt f x y t + (1/2 : ℂ) * ops.Delta f x y t

def EQ02Holds (ops : SchrodingerOperators) (f : Field2D) : Prop :=
  L ops f = fun x y t => 0

/-
Lemmas showing the closure of plane waves under the operators iDt and negHalfDelta, formulated pointwise.
-/
theorem iDt_planeWave_closed (ops : SchrodingerOperators) (A : ℂ) (kx ky : ℝ) :
  (fun x y t => Complex.I * ops.Dt (planeWave A kx ky) x y t) =
  (fun x y t => omega kx ky * planeWave A kx ky x y t) := by
    -- By definition of $ops.Dt$, we know that $ops.Dt (planeWave A kx ky) = fun x y t => -Complex.I * omega kx ky * planeWave A kx ky x y t$.
    have hDt : ops.Dt (planeWave A kx ky) = fun x y t => -Complex.I * omega kx ky * planeWave A kx ky x y t := by
      exact ops.Dt_planeWave A kx ky;
    funext x y t; rw [ hDt ] ; ring_nf; norm_num;

theorem negHalfDelta_planeWave_closed (ops : SchrodingerOperators) (A : ℂ) (kx ky : ℝ) :
  (fun x y t => (1/2 : ℂ) * ops.Delta (planeWave A kx ky) x y t) =
  (fun x y t => -omega kx ky * planeWave A kx ky x y t) := by
    ext x y t; have := ops.Delta_planeWave A kx ky; simp_all +decide [ funext_iff, Complex.ext_iff ];
    constructor <;> ring

/-
Definition of eigC and the theorem EQ02Holds_planeWave_iff.
-/
def eigC (kx ky : ℝ) : ℝ := omega kx ky

theorem EQ02Holds_planeWave_iff (ops : SchrodingerOperators) (A : ℂ) (kx ky : ℝ) :
  EQ02Holds ops (planeWave A kx ky) ↔
  (fun x y t => omega kx ky * planeWave A kx ky x y t) = (fun x y t => eigC kx ky * planeWave A kx ky x y t) := by
    unfold eigC EQ02Holds;
    simp [L];
    have := ops.Dt_planeWave A kx ky;
    have := ops.Delta_planeWave A kx ky;
    unfold L; ext x y t; simp [this, ‹ops.Dt (planeWave A kx ky) = _›]; ring;
    norm_num

/-
Definition of Perturbation and AdmissibleOnPlaneWave.
-/
def Perturbation := Field2D → Field2D

def AdmissibleOnPlaneWave (P : Perturbation) (A : ℂ) (kx ky : ℝ) : Prop :=
  P (planeWave A kx ky) = fun x y t => 0

/-
Main preservation lemma: If a perturbation vanishes on the plane-wave probe family, the reduced scalar coefficient form is unchanged.
-/
theorem EQ02Pert_planeWave_reduces_to_same_coeff_equality (ops : SchrodingerOperators) (P : Perturbation) (A : ℂ) (kx ky : ℝ) (h : AdmissibleOnPlaneWave P A kx ky) :
  EQ02Holds ops (planeWave A kx ky + P (planeWave A kx ky)) ↔
  (fun x y t => omega kx ky * planeWave A kx ky x y t) = (fun x y t => eigC kx ky * planeWave A kx ky x y t) := by
    unfold AdmissibleOnPlaneWave at h;
    unfold eigC;
    unfold EQ02Holds; norm_num [ h ] ;
    -- Apply the theorem that states the equivalence between EQ02Holds and the equality of the functions involving omega and eigC.
    apply Eq.symm; exact (by
      have := EQ02Holds_planeWave_iff ops A kx ky;
      convert this.mpr _ |> Eq.symm using 1;
      · exact congr_arg _ ( funext fun x => funext fun y => funext fun t => by simp +decide );
      · exact?
    )