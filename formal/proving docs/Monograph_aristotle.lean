/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8cb3d04c-50cb-4514-91dd-a40c27d5e1d2

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e8c5c57b-dd7d-4dbd-98e9-d29bbbbf15fb
-/

/-
# Analysis of Monograph.md for Lean Formalization

## Section 1: Diagnosis of Current Formal State

The `Monograph.md` document describes a "Classical Coherence Field Theory" (CCFT) which is a system of coupled partial differential equations (PDEs).
*   **Formalized Content**: The document provides explicit mathematical forms for the governing equations (CP-NLSE, CE-NWE), the fields ($\phi, \rho, \theta, u, R, K, \chi$), and the energy functionals. The relationships between variables (e.g., Madelung transformation) are explicitly stated.
*   **Missing Formal Details**:
    *   **Function Spaces**: The text assumes standard differentiability ("smooth enough") but does not specify Sobolev spaces ($H^k$) or Schwartz spaces necessary for rigorous PDE analysis in Lean.
    *   **Domain**: The domain is implied to be $\mathbb{R}$ (via Fourier transforms) or a periodic torus $\mathbb{T}$ (via "grid points" and "L_dom"), but this choice must be fixed for formalization.
    *   **Regularity**: The equivalence proofs (e.g., between CP-NLSE and Hydrodynamics) implicitly assume non-vanishing density ($\rho \neq 0$) to avoid singularities in the phase $\theta$, which is a standard but critical gap to close formally.
*   **Implicit Content**: The "LSDA calibration" is treated as an external oracle providing constants ($g_{\text{eff}}$). In a formal theory, these are just arbitrary constants.

## Section 2: Categorization of Formalizable Content

**(A) Already Formal / Nearly Formal**
*   **Definitions of Fields**: $\phi : \mathbb{R} \times \mathbb{R} \to \mathbb{C}$, $\rho, \theta, u, R, K, \chi$.
*   **Governing Equations**: The explicit PDE forms for CP-NLSE ($i\phi_t = \dots$) and CE-NWE ($\phi_{tt} + \dots = 0$).
*   **Algebraic Identities**: The relationships $\rho = |\phi|^2$, $u = \theta_x$.
*   **Constants**: $g_{\text{eff}}, c_1, c_2$, etc., can be defined as parameters.

**(B) Formalizable with Additional Definitions**
*   **Energy Functionals**: Requires defining the measure space and integrability conditions.
*   **Madelung Transformation**: Requires handling the domain where $\rho > 0$ and defining the phase lifting or restricting to simply connected domains.
*   **Conservation Laws**: Proving $d/dt \int |\phi|^2 = 0$ is straightforward given appropriate boundary conditions (vanishing at infinity or periodic).
*   **Equivalence Proofs**: Showing CP-NLSE $\implies$ CE-NWE requires assuming $C^4$ regularity in space and $C^2$ in time.

**(C) Not Suitable for Formalization at This Stage**
*   **"LSDA Microphysics"**: The derivation of constants from "numerical experiments" is outside the scope of the formal theory; these should be treated as axioms or parameters.
*   **"Rotor-Curvature" Physical Interpretation**: The *meaning* of $R$ and $K$ is informal; only their mathematical definitions and coupling terms can be formalized.
*   **Numerical Validation**: The specific numerical results (Tests C1-C13) are not formal proofs, though the *algorithms* could be verified.

## Section 3: Recommended Development Roadmap

**Phase 1: Foundations**
1.  **Define the Domain**: Fix the spatial domain $D$ (likely $\mathbb{R}$ or $\mathbb{T}^1$) and time $I \subseteq \mathbb{R}$.
2.  **Define Parameters**: Create a structure `CCFTParameters` holding $g_{\text{eff}}, \rho_0, c_1, c_2$.
3.  **Define Fields**: Define the bundle of fields, likely as smooth functions $C^\infty(D \times I)$.

**Phase 2: Core Dynamics (CP-NLSE)**
1.  **Define CP-NLSE**: `def is_solution_cp_nlse (\phi : D \times I \to \mathbb{C}) : Prop := ...`
2.  **Define Mass/Energy**: Define the functionals $N(\phi)$ and $E(\phi)$.
3.  **Target Invariant**: Prove `theorem mass_conservation : is_solution_cp_nlse \phi \to \partial_t N(\phi) = 0`.

**Phase 3: Equivalence & Extensions**
1.  **Define CE-NWE**: The second-order equation.
2.  **Equivalence Theorem**: Prove that any smooth solution to CP-NLSE satisfies CE-NWE.
3.  **Hydrodynamic Reduction**: Define $(\rho, u)$ from $\phi$ and derive the fluid equations (Euler-Korteweg type).

**Phase 4: LCRD & Multi-field**
1.  **Define R and K**: As functionals of the primary fields or independent coupled fields.
2.  **Coupling**: Introduce the pressure correction $Q_{\text{rotor}}$ into the momentum equation.

## Section 4: Critical Blockers and Required Clarifications

1.  **Regularity**: The text is silent on the required smoothness. We must decide whether to work with smooth functions (easier for algebraic manipulation) or Sobolev spaces (necessary for existence theory). *Recommendation: Start with smooth functions to verify the algebraic structure.*
2.  **Vacuum States**: The definition $u = \nabla \theta$ is ill-defined where $\phi = 0$. The formalization must explicitly track the non-vanishing condition $\rho > 0$ for the hydrodynamic equivalence to hold.
3.  **Boundary Conditions**: The "invariants" (mass, energy) only hold if boundary terms vanish. We must explicitly assume either compact support, Schwartz decay, or periodic boundary conditions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section



/-
Defining the effective nonlinear coefficient g_eff, the reference density rho_0, and the effective sound speed c_eff.
-/
def g_eff : Real := 9.8696
def rho_0 : Real := 1.0
def c_eff : Real := Real.sqrt g_eff

/-
Defining the CP-NLSE equation for a field phi(x, t). The equation is i * ∂phi/∂t = -1/2 * ∂²phi/∂x² + g_eff * (|phi|² - ρ₀) * phi.
-/
def CP_NLSE (phi : ℝ → ℝ → ℂ) : Prop :=
  ∀ x t : ℝ,
    Complex.I * deriv (fun t' => phi x t') t =
    - (1/2 : ℂ) * deriv (fun x' => deriv (fun x'' => phi x'' t) x') x +
    g_eff * (norm (phi x t) ^ 2 - rho_0) * phi x t

/-
Defining the CE-NWE equation: φ_tt + (1/4)φ_xxxx - g_eff * φ_xx = 0.
-/
def CE_NWE (phi : ℝ → ℝ → ℂ) : Prop :=
  ∀ x t : ℝ,
    deriv (fun t' => deriv (fun t'' => phi x t'') t') t +
    (1/4 : ℂ) * deriv (fun x' => deriv (fun x'' => deriv (fun x''' => deriv (fun x'''' => phi x'''' t) x''') x'') x') x -
    g_eff * deriv (fun x' => deriv (fun x'' => phi x'' t) x') x = 0

/-
Checking for Complex.arg
-/
#check Complex.arg

/-
Defining density rho = |phi|^2 and velocity u = ∂_x(arg(phi)).
-/
def rho (phi : ℝ → ℝ → ℂ) (x t : ℝ) : ℝ := Complex.normSq (phi x t)

def u (phi : ℝ → ℝ → ℂ) (x t : ℝ) : ℝ := deriv (fun x' => Complex.arg (phi x' t)) x

/-
Defining the LCRD equations for rotor field R and curvature field K.
R_t = -alpha_R * R + b_R * u_x + d_R * K
K_t = -alpha_K * K + b_K * u_xx
-/
def LCRD_equations (R K : ℝ → ℝ → ℝ) (u : ℝ → ℝ → ℝ)
    (alpha_R b_R d_R alpha_K b_K : ℝ) : Prop :=
  (∀ x t : ℝ, deriv (fun t' => R x t') t =
    -alpha_R * R x t + b_R * deriv (fun x' => u x' t) x + d_R * K x t) ∧
  (∀ x t : ℝ, deriv (fun t' => K x t') t =
    -alpha_K * K x t + b_K * deriv (fun x' => deriv (fun x'' => u x'' t) x') x)

/-
Defining the coupled φ–χ system.
i * phi_t = -1/2 * phi_xx + g_eff * (|phi|^2 - rho_0) * phi - alpha * chi * phi
chi_tt = (chi - gamma * (rho - rho_0))_xx + lambda_chi * chi_xxxx - beta_chi * chi_xxxxxx
-/
def Phi_Chi_System (phi : ℝ → ℝ → ℂ) (chi : ℝ → ℝ → ℝ)
    (alpha gamma lambda_chi beta_chi : ℝ) : Prop :=
  (∀ x t : ℝ,
    Complex.I * deriv (fun t' => phi x t') t =
    - (1/2 : ℂ) * deriv (fun x' => deriv (fun x'' => phi x'' t) x') x +
    g_eff * (norm (phi x t) ^ 2 - rho_0) * phi x t -
    alpha * (chi x t : ℂ) * phi x t) ∧
  (∀ x t : ℝ,
    deriv (fun t' => deriv (fun t'' => chi x t'') t') t =
    deriv (fun x' => deriv (fun x'' => chi x'' t - gamma * (norm (phi x'' t) ^ 2 - rho_0)) x') x +
    lambda_chi * deriv (fun x' => deriv (fun x'' => deriv (fun x''' => deriv (fun x'''' => chi x'''' t) x''') x'') x') x -
    beta_chi * deriv (fun x1 => deriv (fun x2 => deriv (fun x3 => deriv (fun x4 => deriv (fun x5 => deriv (fun x6 => chi x6 t) x5) x4) x3) x2) x1) x)

/-
Defining the dispersive pressure Q and the hydrodynamic system equations.
Q = -(1/2)(ρ_xx/ρ) + (1/4)(ρ_x/ρ)^2
ρ_t = -(ρ u)_x
u_t = -u u_x - g_eff ρ_x + Q_x
-/
def Q (rho : ℝ → ℝ → ℝ) (x t : ℝ) : ℝ :=
  - (1/2) * (deriv (fun x' => deriv (fun x'' => rho x'' t) x') x) / (rho x t) +
    (1/4) * (deriv (fun x' => rho x' t) x / rho x t) ^ 2

def Hydrodynamic_System (rho u : ℝ → ℝ → ℝ) : Prop :=
  (∀ x t : ℝ, deriv (fun t' => rho x t') t = - deriv (fun x' => rho x' t * u x' t) x) ∧
  (∀ x t : ℝ, deriv (fun t' => u x t') t =
    - u x t * deriv (fun x' => u x' t) x - g_eff * deriv (fun x' => rho x' t) x +
    deriv (fun x' => Q rho x' t) x)

/-
Checking for MeasureTheory.integral and MeasureTheory.volume.
-/
#check MeasureTheory.integral
#check MeasureTheory.volume

/-
Defining the energy functional for the CP-NLSE subsystem.
H = ∫ [ ½ |φ_x|^2 + (g_eff/2) (|φ|^2 - ρ_0)^2 ] dx
-/
def Energy_CP_NLSE (phi : ℝ → ℝ → ℂ) (t : ℝ) : ℝ :=
  MeasureTheory.integral MeasureTheory.volume (fun x =>
    (1/2) * Complex.normSq (deriv (fun x' => phi x' t) x) +
    (g_eff/2) * (Complex.normSq (phi x t) - rho_0)^2)

/-
Defining the energy functional for the CE-NWE subsystem.
E_CE = ∫ [ ½ φ_t² + ⅛ φ_xx² + (g_eff / 2) φ_x² ] dx
-/
def Energy_CE_NWE (phi : ℝ → ℝ → ℝ) (t : ℝ) : ℝ :=
  MeasureTheory.integral MeasureTheory.volume (fun x =>
    (1/2) * (deriv (fun t' => phi x t') t) ^ 2 +
    (1/8) * (deriv (fun x' => deriv (fun x'' => phi x'' t) x') x) ^ 2 +
    (g_eff/2) * (deriv (fun x' => phi x' t) x) ^ 2)

/-
Defining the rotor energy functional.
E_rotor = ∫ (c1/2) R^2 + (c2/2) K^2 dx
-/
def Energy_rotor (R K : ℝ → ℝ → ℝ) (c1 c2 : ℝ) (t : ℝ) : ℝ :=
  MeasureTheory.integral MeasureTheory.volume (fun x =>
    (c1 / 2) * (R x t) ^ 2 + (c2 / 2) * (K x t) ^ 2)

/-
Defining the energy functional for the auxiliary field chi.
E_chi = ∫ [ ½ chi_t² + ½ chi_x² + (lambda_chi / 2) chi_xx² + (beta_chi / 2) chi_xxx² + (gamma / 2) (rho - rho_0) chi_x² ] dx
-/
def Energy_chi (chi : ℝ → ℝ → ℝ) (phi : ℝ → ℝ → ℂ) (lambda_chi beta_chi gamma : ℝ) (t : ℝ) : ℝ :=
  MeasureTheory.integral MeasureTheory.volume (fun x =>
    (1/2) * (deriv (fun t' => chi x t') t)^2 +
    (1/2) * (deriv (fun x' => chi x' t) x)^2 +
    (lambda_chi / 2) * (deriv (fun x' => deriv (fun x'' => chi x'' t) x') x)^2 +
    (beta_chi / 2) * (deriv (fun x' => deriv (fun x'' => deriv (fun x''' => chi x''' t) x'') x') x)^2 +
    (gamma / 2) * (rho phi x t - rho_0) * (deriv (fun x' => chi x' t) x)^2)

/-
Lemma: The time derivative of the density rho is 2 * Re(conj(phi) * phi_t).
-/
lemma rho_time_deriv (phi : ℝ → ℝ → ℂ) (x t : ℝ)
  (h_diff : DifferentiableAt ℝ (fun t' => phi x t') t) :
  deriv (fun t' => rho phi x t') t =
  2 * (Complex.re (starRingEnd ℂ (phi x t) * deriv (fun t' => phi x t') t)) := by
    convert HasDerivAt.deriv _ using 1;
    convert HasDerivAt.norm_sq ( h_diff.hasDerivAt ) using 1;
    · norm_num [ rho, Complex.normSq_eq_norm_sq ];
    · norm_num [ Complex.ext_iff, inner ];
      ring

/-
Defining velocity as Im(phi_x / phi).
-/
def velocity (phi : ℝ → ℝ → ℂ) (x t : ℝ) : ℝ :=
  (deriv (fun x' => phi x' t) x / phi x t).im

/-
Lemma: The spatial derivative of rho * velocity is Im(phi_xx * conj(phi)).
-/
lemma rho_velocity_spatial_deriv (phi : ℝ → ℝ → ℂ) (x t : ℝ)
  (h_diff : DifferentiableAt ℝ (fun x' => phi x' t) x)
  (h_diff2 : DifferentiableAt ℝ (fun x' => deriv (fun x'' => phi x'' t) x') x) :
  deriv (fun x' => rho phi x' t * velocity phi x' t) x =
  Complex.im (deriv (fun x' => deriv (fun x'' => phi x'' t) x') x * starRingEnd ℂ (phi x t)) := by
    field_simp;
    -- By definition of rho and velocity, we can rewrite the product as phi_xx * conjugate(phi).
    have h_prod : deriv (fun x' => rho phi x' t * velocity phi x' t) x = deriv (fun x' => (deriv (fun x'' => phi x'' t) x' * starRingEnd ℂ (phi x' t)).im) x := by
      congr;
      ext x'
      simp [rho, velocity];
      by_cases h : phi x' t = 0 <;> simp +decide [ h, Complex.normSq, div_eq_mul_inv ];
      linarith [ inv_mul_cancel_left₀ ( show ( phi x' t |> Complex.re ) * ( phi x' t |> Complex.re ) + ( phi x' t |> Complex.im ) * ( phi x' t |> Complex.im ) ≠ 0 from fun h' => h <| by refine' Complex.ext _ _ <;> norm_num <;> nlinarith ) ( ( deriv ( fun x' => phi x' t ) x' |> Complex.re ) * ( phi x' t |> Complex.im ) ), inv_mul_cancel_left₀ ( show ( phi x' t |> Complex.re ) * ( phi x' t |> Complex.re ) + ( phi x' t |> Complex.im ) * ( phi x' t |> Complex.im ) ≠ 0 from fun h' => h <| by refine' Complex.ext _ _ <;> norm_num <;> nlinarith ) ( ( deriv ( fun x' => phi x' t ) x' |> Complex.im ) * ( phi x' t |> Complex.re ) ) ];
    have := h_diff2.hasDerivAt;
    have := this.mul ( h_diff.hasDerivAt.star );
    rw [ h_prod ];
    rw [ hasDerivAt_iff_tendsto_slope_zero ] at this;
    refine' HasDerivAt.deriv _;
    rw [ hasDerivAt_iff_tendsto_slope_zero ];
    convert Complex.continuous_im.continuousAt.tendsto.comp this using 2 ; norm_num;
    norm_num [ Complex.ext_iff ];
    ring

/-
Lemma: rho * velocity = Im(phi_x * conj(phi)).
-/
lemma rho_mul_velocity_eq (phi : ℝ → ℝ → ℂ) (x t : ℝ) :
  rho phi x t * velocity phi x t = (deriv (fun x' => phi x' t) x * starRingEnd ℂ (phi x t)).im := by
    unfold rho velocity;
    by_cases h : phi x t = 0 <;> simp +decide [ h, div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Complex.normSq_eq_norm_sq ];
    field_simp

/-
Theorem: The continuity equation holds for rho and velocity under the CP-NLSE dynamics.
-/
theorem Madelung_Continuity_velocity (phi : ℝ → ℝ → ℂ)
  (h_diff_t : ∀ x t, DifferentiableAt ℝ (fun t' => phi x t') t)
  (h_diff_x : ∀ x t, DifferentiableAt ℝ (fun x' => phi x' t) x)
  (h_diff_xx : ∀ x t, DifferentiableAt ℝ (fun x' => deriv (fun x'' => phi x'' t) x') x)
  (h_nonzero : ∀ x t, phi x t ≠ 0) :
  CP_NLSE phi →
  ∀ x t, deriv (fun t' => rho phi x t') t = - deriv (fun x' => rho phi x' t * velocity phi x' t) x := by
    intro h_eq x t
    have h_rho_deriv : deriv (fun t' => rho phi x t') t = 2 * (Complex.re ((starRingEnd ℂ (phi x t)) * (deriv (fun t' => phi x t') t))) := by
      convert rho_time_deriv phi x t ( h_diff_t x t ) using 1
    have h_rho_velocity_deriv : deriv (fun x' => rho phi x' t * (velocity phi x' t)) x = Complex.im (deriv (fun x' => deriv (fun x'' => phi x'' t) x') x * (starRingEnd ℂ (phi x t))) := by
      exact?;
    have h_subst : deriv (fun t' => phi x t') t = Complex.I / 2 * deriv (fun x' => deriv (fun x'' => phi x'' t) x') x - Complex.I * (g_eff * (Complex.normSq (phi x t) - rho_0)) * phi x t := by
      have := h_eq x t;
      rw [ Complex.normSq_eq_norm_sq ] ; norm_num [ Complex.ext_iff ] at * ; constructor <;> linarith;
    -- Substitute h_subst into h_rho_deriv and simplify.
    rw [h_subst] at h_rho_deriv
    simp [h_rho_deriv, h_rho_velocity_deriv] at *;
    ring

/-
Checking if rho_time_deriv is defined.
-/
#check rho_time_deriv

/-
Lemma: The time derivative of velocity is Im((phi_xt * phi - phi_x * phi_t) / phi^2).
-/
lemma velocity_time_deriv_expansion (phi : ℝ → ℝ → ℂ) (x t : ℝ)
  (h_diff_t : DifferentiableAt ℝ (fun t' => phi x t') t)
  (h_diff_xt : DifferentiableAt ℝ (fun t' => deriv (fun x' => phi x' t') x) t)
  (h_nonzero : phi x t ≠ 0) :
  deriv (fun t' => velocity phi x t') t =
  ((deriv (fun t' => deriv (fun x' => phi x' t') x) t * phi x t -
    deriv (fun x' => phi x' t) x * deriv (fun t' => phi x t') t) / (phi x t)^2).im := by
      have h_quotient : deriv (fun t' => (deriv (fun x' => phi x' t') x / phi x t').im) t = ((deriv (fun t' => (deriv (fun x' => phi x' t') x / phi x t')) t).im) := by
        -- The derivative of the imaginary part is the imaginary part of the derivative.
        have h_im_deriv : ∀ f : ℝ → ℂ, DifferentiableAt ℝ f t → deriv (fun t' => (f t').im) t = (deriv f t).im := by
          intro f hf;
          have := hf.hasDerivAt;
          rw [ hasDerivAt_iff_tendsto_slope_zero ] at this;
          refine' HasDerivAt.deriv _;
          rw [ hasDerivAt_iff_tendsto_slope_zero ];
          convert Complex.continuous_im.continuousAt.tendsto.comp this using 2 ; norm_num;
        exact h_im_deriv _ ( DifferentiableAt.div h_diff_xt h_diff_t h_nonzero );
      convert h_quotient using 1 ; erw [ deriv_div ] <;> aesop;